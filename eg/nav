#!/usr/local/bin/perl

use strict;
use warnings;

use Params::Util 0.25 qw{ _INSTANCE };
use PPIx::Regexp;
use PPIx::Regexp::Dumper;
use Term::ReadLine;

@ARGV or die "Need an argument.\n";

my $re = PPIx::Regexp->new( $ARGV[0] )
    or die PPIx::Regexp->errmsg();

my $obj = $re;
my $tr = Term::ReadLine->new( 'Navigate a regular expression' );

my %internal = (
    dump => sub {
	my @args;
	defined $_[0] and @args = split qr{ \s+ }smx, $_[0];
	return PPIx::Regexp::Dumper->new(
	    $obj, @args )->string();
    },
    nav => sub {
	return _safe( $obj->nav() );
    },
    parse => sub {
	my $temp = PPIx::Regexp->new( $_[0] ) or return;
	return ( $obj = $re = $temp );
    },
    reset => sub {
	return ( $obj = $re );
    },
);

sub _safe {
    my ( @args ) = @_;
    my $rslt = join ', ', map {
	ref $_ eq 'ARRAY' ? '[ ' . _safe( @{ $_ } ) . ' ]' : "'$_'"
    } @args;
    $rslt =~ s/ \[ \s+ \] /[]/smxg;
    $rslt =~ s/ ' ( \d+ ) ' /$1/smxg;
    $rslt =~ s/ \[ \s* ( \d+ ) \s* \] /$1/smxg;
    $rslt =~ s/ ' ( \w+ ) ', /$1 =>/smxg;
    return $rslt;
}

while ( defined ( my $buffer = $tr->readline( 'nav> ' ) ) ) {
    $buffer =~ s/ \s+ \z //smx;
    $buffer or next;
    $buffer =~ s/ \A \s+ //smx;
    '#' eq substr $buffer, 0, 1 and next;
    my ( $method, $arg ) = split qr{\s+}smx, $buffer, 2;
    'exit' eq $method and last;
    my $temp = eval {
	$internal{$method} ?
	    $internal{$method}->( $arg ) :
	    $obj->$method( $arg );
    } or do {
	if ( $@ ) {
	    warn $@;
	} else {
	    print "undef\n";
	}
	next;
    };
    if ( _INSTANCE( $temp, 'PPIx::Regexp::Element' ) ) {
	print $temp->class(), "\t", $temp->content(), "\n";
	$obj = $temp;
    } else {
	print $temp =~ m/ \D /smx ? "'$temp'\n" : "$temp\n";
    }
}

__END__

# ex: set textwidth=72 :
